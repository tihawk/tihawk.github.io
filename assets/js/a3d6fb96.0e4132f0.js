"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8584],{5525:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>u,toc:()=>o});var r=t(4848),a=t(8453);const i={slug:"binary-tree-java",title:"binary-tree-java",description:"TODO Add description here",authors:"kiroki",tags:["algorithms","data_structures","java"]},l="binary-tree-java",u={permalink:"/snip/binary-tree-java",source:"@site/snip/binary-tree-java.md",title:"binary-tree-java",description:"TODO Add description here",date:"2025-08-15T11:52:41.000Z",formattedDate:"August 15, 2025",tags:[{label:"algorithms",permalink:"/snip/tags/algorithms"},{label:"data_structures",permalink:"/snip/tags/data-structures"},{label:"java",permalink:"/snip/tags/java"}],hasTruncateMarker:!1,authors:[{name:"Kiril Panayotov Blagoev",title:"Admin",url:"https://github.com/tihawk",imageURL:"https://github.com/tihawk.png",key:"kiroki"}],frontMatter:{slug:"binary-tree-java",title:"binary-tree-java",description:"TODO Add description here",authors:"kiroki",tags:["algorithms","data_structures","java"]},unlisted:!1,nextItem:{title:"bios-read-char-from-keyboard",permalink:"/snip/bios-read-char-from-keyboard"}},s={authorsImageUrls:[void 0]},o=[];function c(e){const n={code:"code",h1:"h1",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Date created: 2024-09-28"}),"\n",(0,r.jsx)(n.h1,{id:"binary-tree-in-java-with-add-contains-delete-and-traverse-in-order",children:"Binary tree in Java with add, contains, delete, and traverse in order"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class BinaryTree {\n  \n  Node root;\n  \n  static class Node {\n    int value;\n    Node left;\n    Node right;\n    \n    Node(int value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n    }\n  }\n  \n  /* ADD */\n  \n  public void add(int value) {\n    this.root = addRecursive(this.root, value);\n  }\n  \n  private Node addRecursive(Node current, int value) {\n    if (current == null) {\n      return new Node(value);\n    }\n    \n    if (value < current.value) {\n      current.left = addRecursive(current.left, value);\n    } else if (value > current.value) {\n      current.right = addRecursive(current.right, value);\n    } else {\n      // the values are equal, i.e. the node already exists\n      return current;\n    }\n    \n    return current;\n  }\n  \n  /* CONTAINS */\n  \n  public boolean contains(int value) {\n    return containsRecursive(this.root, value);\n  }\n  \n  private boolean containsRecursive(Node current, int value) {\n    if (current == null) {\n      return false;\n    }\n    if (current.value == value) {\n      return true;\n    }\n    \n    if (value < current.value) {\n      return containsRecursive(current.left, value);\n    } else {\n      return containsRecursive(current.right, value);\n    }\n  }\n  \n  /* DELETE */\n  \n  public void delete(int value) {\n    this.root = deleteRecursive(this.root, value);\n  }\n  \n  private Node deleteRecursive(Node current, int value) {\n    if (current == null) {\n      return null;\n    }\n    \n    if (current.value == value) {\n      if (current.left == null && current.right == null) {\n        // Both children are null, replace root with null\n        return null;\n      }\n      \n      if (current.left == null) {\n        // only left is null, replace root with right\n        return current.right;\n      }\n      \n      if (current.right == null) {\n        // only right is null, replace root with left\n        return current.left;\n      }\n      \n      // if both children are non-null, we have to reorganise the subtree\n      // we replace the soon-to-be-deleted node\'s value with the smallest value\n      // of the right branch of the subtree\n      int smallest = getSmallestValue(current.right);\n      current.value = smallest;\n      // after we assign the "deleted" node with the smallest value of the right subtree\n      // we can delete the smallest value from the right subtree\n      current.right = deleteRecursive(current.right, smallest);\n      return current;\n      \n    } else if (value < current.value) {\n      current.left = deleteRecursive(current.left, value);\n      return current;\n    }\n    // else right + default\n    current.right = deleteRecursive(current.right, value);\n    return current;\n  }\n  \n  private int getSmallestValue(Node root) {\n    return root.left == null ? root.value : getSmallestValue(root.left);\n  }\n  \n  /* TRAVERSE */\n  \n  /* DEPTH-FIRST */\n  \n  /* IN-ORDER */\n  \n  public void listInOrder() {\n    traverseInOrder(this.root);\n    System.out.print("\\n");\n  }\n  \n  private void traverseInOrder(Node root) {\n    if (root != null) {\n      traverseInOrder(root.left);\n      System.out.print(root.value + " ");\n      traverseInOrder(root.right);\n    }\n  }\n  \n  public static void main(String args[]) {\n\n    BinaryTree bt = new BinaryTree();\n    \n    bt.add(2);\n    bt.add(6);\n    bt.add(5);\n    bt.add(8);\n    bt.add(9);\n    bt.add(4);\n    bt.add(1);\n    \n    bt.listInOrder();\n    \n    System.out.println(bt.contains(2));\n    System.out.println(bt.contains(3));\n    System.out.println(bt.contains(6));\n    \n    bt.delete(1);\n    System.out.println(bt.contains(1));\n    bt.delete(2);\n    System.out.println(bt.contains(2));\n    System.out.println(bt.contains(4));\n    \n    bt.listInOrder();\n  }\n}\n'})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>u});var r=t(6540);const a={},i=r.createContext(a);function l(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function u(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);