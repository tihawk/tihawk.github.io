"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3719],{2335:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var s=t(4848),a=t(8453);const i={slug:"on-shebangs-being-funky",title:"On shebangs, and their funky behaviour",description:"Shebangs, or interpreter directives have been around since the '80s. They help select interpreters for the little scripts we write. But I realised I've never really looked into why am I writing this magic line of nonsense in the beginning of scripts. And of course, what are its limitations and/or weird associated behaviours we can make use of?",authors:"kiroki",tags:["Coding","Scripting","Programming","Linux"]},r=void 0,o={permalink:"/blog/on-shebangs-being-funky",source:"@site/blog/2025-02-20on-shebangs-being-funky.md",title:"On shebangs, and their funky behaviour",description:"Shebangs, or interpreter directives have been around since the '80s. They help select interpreters for the little scripts we write. But I realised I've never really looked into why am I writing this magic line of nonsense in the beginning of scripts. And of course, what are its limitations and/or weird associated behaviours we can make use of?",date:"2025-02-20T00:00:00.000Z",formattedDate:"February 20, 2025",tags:[{label:"Coding",permalink:"/blog/tags/coding"},{label:"Scripting",permalink:"/blog/tags/scripting"},{label:"Programming",permalink:"/blog/tags/programming"},{label:"Linux",permalink:"/blog/tags/linux"}],readingTime:7.275,hasTruncateMarker:!1,authors:[{name:"Kiril Panayotov Blagoev",title:"Admin",url:"https://github.com/tihawk",imageURL:"https://github.com/tihawk.png",key:"kiroki"}],frontMatter:{slug:"on-shebangs-being-funky",title:"On shebangs, and their funky behaviour",description:"Shebangs, or interpreter directives have been around since the '80s. They help select interpreters for the little scripts we write. But I realised I've never really looked into why am I writing this magic line of nonsense in the beginning of scripts. And of course, what are its limitations and/or weird associated behaviours we can make use of?",authors:"kiroki",tags:["Coding","Scripting","Programming","Linux"]},unlisted:!1,prevItem:{title:"The Monitor - Bootstrapping a PC from BIOS",permalink:"/blog/bootstrapping-a-pc-from-bios-the-monitor"},nextItem:{title:"The Winamp GitHub repository is seriously mismanaged. And there's nothing they can do about it now.",permalink:"/blog/winamp-github-repository-problems"}},h={authorsImageUrls:[void 0]},l=[{value:"Shebang, or the interpreter directive",id:"shebang-or-the-interpreter-directive",level:2},{value:"Interpreters, you say",id:"interpreters-you-say",level:2},{value:"Well, JavaScript is interpreted too",id:"well-javascript-is-interpreted-too",level:3},{value:"Arguments in a shebang line",id:"arguments-in-a-shebang-line",level:2},{value:"Interpreter directive arguments",id:"interpreter-directive-arguments",level:3},{value:"Passing multiple arguments to the shebang line",id:"passing-multiple-arguments-to-the-shebang-line",level:3},{value:"Nesting shebang calls",id:"nesting-shebang-calls",level:2},{value:"And now with arguments",id:"and-now-with-arguments",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"shebang-or-the-interpreter-directive",children:"Shebang, or the interpreter directive"}),"\n",(0,s.jsxs)(n.p,{children:["Have you ever wondered what's that magical first line that you put on top of your scripts, and starts with the characters ",(0,s.jsx)(n.code,{children:"#!"})," ?"]}),"\n",(0,s.jsxs)(n.p,{children:["You might've seen it, for example, in the form of ",(0,s.jsx)(n.code,{children:"#!/usr/bin/env bash"})," on the first line of every bash script you've ever written or seen."]}),"\n",(0,s.jsx)(n.p,{children:"But why is it there, and what does it do?"}),"\n",(0,s.jsxs)(n.p,{children:["This so-called ",(0,s.jsx)(n.em,{children:"shebang"})," line is a Unix feature which was introduced ",(0,s.jsx)(n.a,{href:"https://homepages.cwi.nl/~aeb/std/shebang/origin.html",children:"back in 1980"})," to allow for scripts to be run as executables by specifying the interpreter that the script needs to run itself. This simply means that with the shebang you're abstracting away the call to the interpreter, and instead of calling ",(0,s.jsx)(n.code,{children:"bash script.sh"})," you can now just say ",(0,s.jsx)(n.code,{children:"./script.sh"}),". That's mostly all there is to it. And yes, it's technically called an ",(0,s.jsx)(n.em,{children:"interpreter directive"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["What happens in the background, is that the program loader finds the interpreter you've specified in your ",(0,s.jsx)(n.code,{children:"PATH"})," variable, runs it, and passes the location of your script to the interpreter as an argument. You can see that much in your process viewer as well."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'$ cat > shebang.sh\n#! /usr/bin/env bash\necho "SHEBANG!"\nread\n^C\n$ chmod +x shebang.sh\n$ ./shebang.sh & ps -aux | grep shebang\n[2] 276038\nSHEBANG!\nkblagoev  276038  0.0  0.0  13156  3584 pts/5    T    13:55   0:00 bash ./shebang.sh\n\n[2]+  Stopped                 ./shebang.sh\n$ fg\n./shebang.sh\n^C\n$\n'})}),"\n",(0,s.jsx)(n.h2,{id:"interpreters-you-say",children:"Interpreters, you say"}),"\n",(0,s.jsxs)(n.p,{children:["If you've also written Python scripts, you surely have seen that you can pass a shebang to the python script as well. Since Python is an interpreted language, it actually works in precisely the same way w.r.t. the shebang line. You can simply write ",(0,s.jsx)(n.code,{children:"#!/usr/bin/env python3"})," at the top of your script, make it executable, and suddenly the program loader knows to run the python interpreter and pass your script location as an argument."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:'title="test.py"',children:'#!/usr/bin/env python3\n\nprint("Hello from the Python interpreter")\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ chmod +x test.py\n$ ./test.py\nHello from the Python interpreter\n"})}),"\n",(0,s.jsx)(n.h3,{id:"well-javascript-is-interpreted-too",children:"Well, JavaScript is interpreted too"}),"\n",(0,s.jsxs)(n.p,{children:["Oh, how right you are! For some reason it never occured to me before, but since JavaScript is also a non-compiled, interpreted language, we should be able to make any scripts written in JS into executable files by providing a shebang line to it with some JS runtime like ",(0,s.jsx)(n.em,{children:"node"})," or ",(0,s.jsx)(n.em,{children:"bun"}),", right?"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",metastring:'title="test.js"',children:'#!/usr/bin/env node\n\nconsole.log("Hello from Node, it being a javascript interpreter and all")\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ chmod +x test.js\n$ ./test.js\nHello from Node, it being a javascript interpreter and all\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Yep. That's really cool, if you ask me! Now, technically there is a limitation here. As you've noticed, the shebang line starts with a ",(0,s.jsx)(n.em,{children:"hash"})," symbol, and there's a good reason for that. The ",(0,s.jsx)(n.code,{children:"#"})," symbol is used as a comment in many scripting languages, like shell and python, and it has been chosen for exactly that reason - to not break the syntax that the interpreter for shell expects. But in JavaScript ",(0,s.jsx)(n.code,{children:"#"})," is not a comment. So, technically this would break JS syntax. And as such, it's up to each JS interpreter to implement the ignoring of shebang lines - basically a first line of a script file which starts with ",(0,s.jsx)(n.code,{children:"#"})," or ",(0,s.jsx)(n.code,{children:"#!"})," I guess. As such, with languages that don't support ",(0,s.jsx)(n.em,{children:"hash"})," comments your milage may vary depending on the interpreter implementation. But hey, it works on node!"]}),"\n",(0,s.jsxs)(n.p,{children:["I leave it as an exercise for the reader to see if your favourite scripting language works with shebang lines :) Odds are, it does - as long as either the language already has ",(0,s.jsx)(n.code,{children:"#"})," as a comment, or your interpreter has implemented ignoring shebang lines."]}),"\n",(0,s.jsx)(n.h2,{id:"arguments-in-a-shebang-line",children:"Arguments in a shebang line"}),"\n",(0,s.jsx)(n.h3,{id:"interpreter-directive-arguments",children:"Interpreter directive arguments"}),"\n",(0,s.jsxs)(n.p,{children:["So, technically the the shebang syntax is defined as ",(0,s.jsx)(n.code,{children:"#! interpreter [optional-one-arg-only]"}),". This means that the ",(0,s.jsx)(n.code,{children:"interpreter"})," is actually the first value provided after the magic number ",(0,s.jsx)(n.code,{children:"#!"}),". So, we could write simply ",(0,s.jsx)(n.code,{children:"#! /bin/bash"})," and hope that the ",(0,s.jsx)(n.em,{children:"bash"})," is located at ",(0,s.jsx)(n.code,{children:"/bin/bash"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["But, as we've seen, we actually usually write more so something like ",(0,s.jsx)(n.code,{children:"#! /usr/bin/env bash"}),', meaning that the "interpreter" is actually ',(0,s.jsx)(n.code,{children:"/usr/bin/env"}),", and we have an additional optional param called ",(0,s.jsx)(n.code,{children:"bash"}),". This isn't really what's happening though. What we're saying here, is that we are going to look for ",(0,s.jsx)(n.code,{children:"bash"})," inside the ",(0,s.jsx)(n.code,{children:"PATH"})," variable. This helps with the portability of scripts between different OSs, as we can't guarantee that the interpreter will be in the same location on each OS."]}),"\n",(0,s.jsx)(n.p,{children:"But, by doing this, we've also used up all of our 1 available optional arguments we can pass into the shebang line. So, if we need to pass an argument to an interpreter, we are out of luck."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",metastring:'title="arguments_not_working.js"',children:'#!/usr/bin/env node -e console.log(\\"Running this through the shebang line\\")\n'})}),"\n",(0,s.jsx)(n.p,{children:'If we try running this, we would always get an error that saying "No such file or directory"'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ chmod +x arguments_not_working.js\n$ ./arguments_not_working.js\n/usr/bin/env: 'node -e console.log(\\\\\"Running this through the shebang line\\\\\")': No such file or directory\n/usr/bin/env: use -[v]S to pass options in shebang lines\n"})}),"\n",(0,s.jsx)(n.h3,{id:"passing-multiple-arguments-to-the-shebang-line",children:"Passing multiple arguments to the shebang line"}),"\n",(0,s.jsxs)(n.p,{children:["But hey, what's that thing on the bottom saying? Well, we can actually ",(0,s.jsx)(n.a,{href:"https://www.gnu.org/software/coreutils/manual/html_node/env-invocation.html#g_t_002dS_002f_002d_002dsplit_002dstring-usage-in-scripts",children:"pass multiple arguments"})," to the shebang line, using the ",(0,s.jsx)(n.code,{children:"-S"})," flag! It's not guaranteed to work on every system, so it may reduce portability. But it's still a thing we can try."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",metastring:'title="arguments_working.js"',children:'#!/usr/bin/env -S node -e console.log(\\""Running\\_this\\_through\\_the\\_shebang\\_line\\"")\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ chmod +x arguments_working.js\n$ ./arguments_working.js\nRunning this through the shebang line\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As you notice that the ",(0,s.jsx)(n.a,{href:"https://www.gnu.org/software/coreutils/manual/html_node/env-invocation.html#Escape-sequences",children:"-S escape sequences"})," can be somewhat nightmarish, but in more common scenarios you shouldn't need them that much."]}),"\n",(0,s.jsxs)(n.p,{children:["You can also optionally replace the ",(0,s.jsx)(n.code,{children:"-S"})," argument with ",(0,s.jsx)(n.code,{children:"-vS"})," if you need to debug the arguments you're passing down to the interpreter."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ ./arguments_working.js\nsplit -S:  'node -e console.log(\\\\\"\"Running\\\\_this\\\\_through\\\\_the\\\\_shebang\\\\_line\\\\\"\")'\n into:    'node'\n     &    '-e'\n     &    'console.log(\"Running this through the shebang line\")'\nexecuting: node\n   arg[0]= 'node'\n   arg[1]= '-e'\n   arg[2]= 'console.log(\"Running this through the shebang line\")'\n   arg[3]= './arguments_working.js'\nRunning this through the shebang line\n"})}),"\n",(0,s.jsx)(n.h2,{id:"nesting-shebang-calls",children:"Nesting shebang calls"}),"\n",(0,s.jsxs)(n.p,{children:["Now, we've been saying that the shebang line is used to specify an interpreter to run the script file. But what's an interpreter? On the highest of levels, it's some ",(0,s.jsx)(n.em,{children:"binary"})," that can execute scripts in a given language. But for the purposes of the program loader, a binary is just an executable file. And at the start of the article said that we can make script files executable by providing them with a shebang line."]}),"\n",(0,s.jsxs)(n.p,{children:["So, what's stopping us from calling ",(0,s.jsx)(n.em,{children:"any"}),' executable file from a shebang line, including files that are only executable because they have their own shebang line? Well, let me answer this clearly rhetorically stated by me question with the laconic "nothing". So, let\'s test this with a contrived example.']}),"\n",(0,s.jsx)(n.p,{children:"First, we create a JavaScript script with a shebang line."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",metastring:"title=~/code/scripts/js.js",children:'#! /usr/bin/env node\n\nconsole.log("Hi from JS")\n'})}),"\n",(0,s.jsx)(n.p,{children:"Then, let us create a random-ass file with just a shebang line to call our JS script. Do notice the file locations specified."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="sheshotmedown.bangbang"',children:"#! /usr/bin/env -S ${HOME}/code/scripts/js.js\n"})}),"\n",(0,s.jsx)(n.p,{children:"Aaaand, let's see what we've done."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ chmod +x sheshotmedown.bangbang js.js\n$ ./sheshotmedown.bangbang\nHi from JS\n"})}),"\n",(0,s.jsx)(n.p,{children:"Honestly, upon this realisation I just went \"Daaaang!\". You can basically set up a weird-ass dependency chain this way. Not that you'd want to, probably, but this is still hilariously amusing to me. Let's see if it works with one more layer, but with a local directory call."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="ihittheground.bangbang"',children:"#! ./sheshotmedown.bangbang\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ chmod +x ihittheground.bangbang\n$ ./ihittheground.bangbang\nHi from JS\n"})}),"\n",(0,s.jsx)(n.p,{children:"Yep, we got it down. We can just call random executable files from within the shebang line."}),"\n",(0,s.jsx)(n.h3,{id:"and-now-with-arguments",children:"And now with arguments"}),"\n",(0,s.jsx)(n.p,{children:"The last thing I wanted to showcase, is the fact that you keep passing the shebang arguments down the chain of calls. Let's do one final experiment"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",metastring:'title="bangbang.js"',children:'#! /usr/bin/env -S BANG="He\\_wore\\_black\\_and\\_I\\_wore\\_white" node\nconsole.log([...process.argv, process.env.BANG, "He would always win the fight"])\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="mybabyshotmedown.bangbang"',children:'#! /usr/bin/env -S ./thatawfulsound.bangbang "We\\_rode\\_on\\_horses\\_made\\_of\\_sticks"\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="thatawfulsound.bangbang"',children:'#! /usr/bin/env -S ./bangbang.js "I\\_was\\_five,\\_and\\_he\\_was\\_six" \n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ chmod +x mybabyshotmedown.bangbang thatawfulsound.bangbang bangbang.js\n$ ./mybabyshotmedown.bangbang\n[\n  '/home/kblagoev/.nvm/versions/node/v18.14.0/bin/node',\n  '/home/kblagoev/code/scripts/bangbang.js',\n  'I was five, and he was six',\n  './thatawfulsound.bangbang',\n  'We rode on horses made of sticks',\n  './mybabyshotmedown.bangbang',\n  'He wore black and I wore white',\n  'He would always win the fight'\n]\n"})}),"\n",(0,s.jsx)(n.p,{children:'As you can see, we kept the arguments we passed through the shebang lines down until the last call of the Node script. And additionally, we get the "interpreters" called from the shebang line as arguments as well. Pretty neat.'}),"\n",(0,s.jsx)(n.p,{children:"Anyway, I hope you've had fun with this, and maybe you can actually apply it somewhere - who knows. Have fun!"})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);