"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4670],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=s(n),m=a,f=c["".concat(p,".").concat(m)]||c[m]||d[m]||o;return n?r.createElement(f,l(l({ref:t},u),{},{components:n})):r.createElement(f,l({ref:t},u))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=m;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[c]="string"==typeof e?e:a,l[1]=i;for(var s=2;s<o;s++)l[s]=n[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1487:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>s});var r=n(7462),a=(n(7294),n(3905));const o={slug:"soulcrabber-cyberapocalypse-2021-ctf",title:"Soulcrabber - Cyberapocalypse 2021 CTF",description:"This is a writeup for the Soulcrabber challenge, part of the Hack the box's Cyberapocalypse CTF 2021, category Crypto.",authors:"kiroki",tags:["Cyber Security","CTF"]},l=void 0,i={permalink:"/blog/soulcrabber-cyberapocalypse-2021-ctf",source:"@site/blog/2021-04-27-15:35:53soulcrabber-cyberapocalypse-2021-ctf.md",title:"Soulcrabber - Cyberapocalypse 2021 CTF",description:"This is a writeup for the Soulcrabber challenge, part of the Hack the box's Cyberapocalypse CTF 2021, category Crypto.",date:"2021-04-27T00:00:00.000Z",formattedDate:"April 27, 2021",tags:[{label:"Cyber Security",permalink:"/blog/tags/cyber-security"},{label:"CTF",permalink:"/blog/tags/ctf"}],readingTime:2.605,hasTruncateMarker:!0,authors:[{name:"Kiril Panayotov Blagoev",title:"Admin",url:"https://github.com/tihawk",imageURL:"https://github.com/tihawk.png",key:"kiroki"}],frontMatter:{slug:"soulcrabber-cyberapocalypse-2021-ctf",title:"Soulcrabber - Cyberapocalypse 2021 CTF",description:"This is a writeup for the Soulcrabber challenge, part of the Hack the box's Cyberapocalypse CTF 2021, category Crypto.",authors:"kiroki",tags:["Cyber Security","CTF"]},prevItem:{title:"Emoji Voting - Cyberapocalypse 2021 CTF",permalink:"/blog/emoji-voting-cyberapocalypse-2021-ctf"},nextItem:{title:"Wild goose hunt - Cyberapocalypse 2021 CTF",permalink:"/blog/wild-goose-hunt-cyberapocalypse-2021-ctf"}},p={authorsImageUrls:[void 0]},s=[{value:"Propmpt",id:"propmpt",level:3},{value:"Recon",id:"recon",level:3},{value:"Solution",id:"solution",level:3}],u={toc:s},c="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This is a writeup for the Soulcrabber challenge, part of the Hack the box's Cyberapocalypse CTF 2021, category Crypto."),(0,a.kt)("h3",{id:"propmpt"},"Propmpt"),(0,a.kt)("p",null,"Aliens heard of this cool newer language called Rust, and hoped the safety it offers could be used to improve their stream cipher."),(0,a.kt)("h3",{id:"recon"},"Recon"),(0,a.kt)("p",null,"We get a Rust script which applies a seemingly random XOR cypher to a ",(0,a.kt)("inlineCode",{parentName:"p"},"flag.txt")," file, and outputs it in ",(0,a.kt)("em",{parentName:"p"},"hex")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"out.txt"),". We also get the output file, so all we have to do is reverse the procedure."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use rand::{Rng,SeedableRng};\nuse rand::rngs::StdRng;\nuse std::fs;\nuse std::io::Write;\n\nfn get_rng() -> StdRng {\n    let seed = 13371337;\n    return StdRng::seed_from_u64(seed);\n}\n\nfn rand_xor(input : String) -> String {\n    let mut rng = get_rng();\n    return input\n        .chars()\n        .into_iter()\n        .map(|c| format!("{:02x}", (c as u8 ^ rng.gen::<u8>())))\n        .collect::<Vec<String>>()\n        .join("");\n}\n\nfn main() -> std::io::Result<()> {\n    let flag = fs::read_to_string("flag.txt")?;\n    let xored = rand_xor(flag);\n    println!("{}", xored);\n    let mut file = fs::File::create("out.txt")?;\n    file.write(xored.as_bytes())?;\n    Ok(())\n}\n')),(0,a.kt)("p",null,"Sequence of events:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Open a file ",(0,a.kt)("inlineCode",{parentName:"li"},"flag.txt"),"."),(0,a.kt)("li",{parentName:"ol"},"Generate a random key for XOR by using the seed ",(0,a.kt)("inlineCode",{parentName:"li"},"13371337"),"."),(0,a.kt)("li",{parentName:"ol"},"XOR the contents of ",(0,a.kt)("inlineCode",{parentName:"li"},"flag.txt")," with the key."),(0,a.kt)("li",{parentName:"ol"},"Write out the result onto ",(0,a.kt)("inlineCode",{parentName:"li"},"out.txt"),".")),(0,a.kt)("p",null,"Although the code for XOR is generated by a random number generator, we immediately notice that the RNG is supplied with a known seed. This automatically means, that the numbers generated by it will follow the same sequence every time."),(0,a.kt)("p",null,"So all we have to do to reverse the process is to supply ",(0,a.kt)("inlineCode",{parentName:"p"},"out.txt")," as input (in hex) to the function, and we will get the original flag in hex as output."),(0,a.kt)("h3",{id:"solution"},"Solution"),(0,a.kt)("p",null,"Sequence:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Read the hex value contents of ",(0,a.kt)("inlineCode",{parentName:"li"},"out.txt"),"."),(0,a.kt)("li",{parentName:"ol"},"Generate the pseudo-random key by using the same seed."),(0,a.kt)("li",{parentName:"ol"},"XOR the contents of ",(0,a.kt)("inlineCode",{parentName:"li"},"out.txt"),"."),(0,a.kt)("li",{parentName:"ol"},"Write the XORed value onto ",(0,a.kt)("inlineCode",{parentName:"li"},"flag.txt"),"."),(0,a.kt)("li",{parentName:"ol"},"Represent the hex value of the key in ASCII using ",(0,a.kt)("inlineCode",{parentName:"li"},"xxd"),".")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use rand::{Rng,SeedableRng};\nuse rand::rngs::StdRng;\nuse std::fs;\nuse std::io::Write;\nuse std::io::prelude::*;\n\nfn get_rng() -> StdRng {\n    let seed = 13371337;\n    return StdRng::seed_from_u64(seed);\n}\n\nfn rand_xor(input :&mut [u8]) -> String {\n    let mut rng = get_rng();\n    return input\n        // .chars()\n        .into_iter()\n        .map(|c| format!("{:02x}", (*c ^ rng.gen::<u8>())))\n        .collect::<Vec<String>>()\n        .join("");\n}\n\nfn main() -> std::io::Result<()> {\n    // we now read the file contents into a vector of u8 values\n    let mut file_content = Vec::new();\n    let mut file = fs::File::open("out.txt").expect("Unable to open file");\n    file.read_to_end(&mut file_content).expect("Unable to read");\n    let xored = rand_xor(&mut file_content);\n    println!("{}", xored);\n    let mut file = fs::File::create("flag.txt")?;\n    file.write(xored.as_bytes())?;\n    Ok(())\n}\n')),(0,a.kt)("p",null,"Of course, since this is the first time I had to deal with Rust, I had to install a lot of stuff first. After that, to generate the needed files to build the project, we run:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"cargo init")," in the project folder to generate a templated ",(0,a.kt)("inlineCode",{parentName:"li"},"Cargo.toml")," file."),(0,a.kt)("li",{parentName:"ol"},"Add ",(0,a.kt)("inlineCode",{parentName:"li"},"rand = '*'")," under ",(0,a.kt)("inlineCode",{parentName:"li"},"[dependencies]")," inside ",(0,a.kt)("inlineCode",{parentName:"li"},"Cargo.toml"),"."),(0,a.kt)("li",{parentName:"ol"},"Run ",(0,a.kt)("inlineCode",{parentName:"li"},"cargo build")," to build the project."),(0,a.kt)("li",{parentName:"ol"},"Run it with ",(0,a.kt)("inlineCode",{parentName:"li"},"cargo run"),".")),(0,a.kt)("p",null,"We now have the hex representation of the flag inside our ",(0,a.kt)("inlineCode",{parentName:"p"},"flag.txt")," file, so we can simply run"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"cat flag.txt | xxd -r -ps\n")),(0,a.kt)("p",null,"and we get our flag"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"CHTB{mem0ry_s4f3_crypt0_f41l}\n")),(0,a.kt)("p",null,"Thanks for reading!"))}d.isMDXComponent=!0}}]);